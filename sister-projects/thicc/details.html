<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Mathematical Musings behind Thicc Curve (Stephanie Björk; Sep 2, 2017)
  </title>
  <link rel="stylesheet" href="styles/main.css" type="text/css" />
  <link rel="stylesheet" href="styles/details.css" type="text/css" />
</head>
<body>
  <div id="container">
    <div id="front-matter">
      <div id="heading">
        <h1>Mathematical Musings behind Thicc Curve</h1>
        <div id="author-date">
          <h2>Stephanie Björk</h2>
          <h2>Sep 2, 2017</h2>
          <!-- Finished writing: Sep 6, 2017 -->
        </div>
      </div>

      <div id="dedication">
        <h3>Dedicated to Bjørk</h3>

        <p>My first best friend with whom I had the best musings and
        discussions, laughter and tears at 3 AM. Whilst everyone was asleep and
        handling the madness that which this world presents to them, we would
        forget about life and be contented about what little but significant we
        had. My first best friend without whom this paper would never have
        existed. Still my best friend, I love and miss her very much to this
        very day.</p>
      </div>

      <div id="abstract">
        <h3>Abstract</h3>
        <p>I trust that many of you may have already seen the <a
           href="curve.html">Thicc Curve</a>, wondered, and became intrigued
         at how it was made possible using allegedly nothing but HTML and SCSS.
         As such, a significant proportion of you may have already tried
         examining the HTML and CSS code of the webpage with the help of an
         element inspector or source code viewer in their web browsers, but only
         to find a preposterous amount of seemingly blank <code>div</code> tags
         in the HTML document and hundreds of styling rules spanning over one
         thousand lines in the CSS document. It is of no doubt that this method
         of inspection is of nearly no help and only leaves one ever more
         confused in general. This is partly because of the fact that much of
         the inner workings is actually hidden within the source code that
         generally needs to be preprocessed and compiled before it can be used
         to render the figure on the web browser. The inner workings, when
         looked at carefully under the correct scope, will yield a simple enough
         explanation as to how exactly the figure was rendered.</p>

        <p>The purpose of this document is to clarify how the <em>Thicc
          Curve</em> was constructed from nothing but HTML and SCSS, not even an
        image or SVG file. Some background information will also be given.
        Topics including but not limited to HTML and SCSS, basic mathematical
        operations (exponentiations, factorials, and trigonometric functions),
        and the Maclaurin Series will be discussed. Thus, basic skills in those
        disciplines is a prerequisite before reading this document. Although
        basic high school mathematics refresher sections will be inserted at
        intervals wherever it behoves me to add, a basic understanding of high
        school mathematics is another crucial prerequisite as well. These topics
        are listed here in no particular order; they will be arranged into
        sections in the main matter of this document.</p>
      </div>
    </div>

    <div id="main-matter">
      <h1>Foreword</h1>
      <p>Insofar, you have probably already seen the <a href="curve.html">Thicc
        Curve</a> and became stumped as to how the rendering of this figure
      could be achieved using nothing but HTML and SCSS, not even an image or
      SVG file. The curious observer would probably have checked the source HTML
      and CSS code that the browser requested from a remote webserver, but only
      to find a bunch of preposterous and inconcievable rules written by machine
      for machine. So, here you are: perhaps you already know the answer as to
      how it was done and are just curious, or maybe you really don't. In this
      section, we'll look at the things you should already have known upon a
      casual glance at the code just so as to establish sufficient context so
      that we are on the same boat and things you should know about the
      background of the figure.</p>

      <div class="figure-container">
        <img src="images/inspection1.png" alt="Overview of the Thicc Curve's
        preposterous inner-workings." />
        <p>Overview of the Thicc Curve's preposterous inner-workings. (Author;
        Sep 3, 2017)</p>
      </div>

      <p>Of course, peering through the code, one can tell straight away that
      much of it has been generated by a preprocessing algorithm run on a
      machine, especially much of the CSS code one can see. Indeed, this is no
      secret: although much of the work put into rendering the figure is done on
      SCSS (Sassy CSS) code, browsers cannot understand SCSS code directly, so
      they need to be compiled into browser-compatible traditional CSS. Most of
      the HTML code is also machine-generated: all of the empty <code>div</code>
      elements, but not the textual documentation section and the rest of the
      code to be precise. Of course, what type of sane human being would be
      crazy enough to type out 314 empty <code>div</code>s, line by line, all
      by hand?! Here is a cliché: What type of sane human being would be crazy
      enough to make <em>Thicc Curve</em>? That would be me, of course!
      </p>

      <p>Looking past the code, however, I admit that it's a really stupid web
      document, and the orthography in the description is an absolute eyesore
      and way worse than an average YouTuber's comment's grammar. Suffice it to
      say, the focus of this entire thing should be at the code and how it all
      works to create a theoretically "stunning"-looking curve seen on the left
      of the viewport. As a side note, it does look terribly like an erection,
      but please keep those jokes at bay for now. Thanks. :)</p>

      <p>Now, it is time for a bit of background. It is not everyday that I make
      something as fun and as useless as <em>Thicc Curve</em>. Not everyday was
      4 o'clock at the morning of September 2, 2017. I had been learning
      SCSS for quite some time and I had just reached the part of the
      documentation where I got to play around with the limited mathematical
      operations it had. After finishing the module of the course for the day, I
      dared to challenge myself to implement many complex mathematical features
      for trigonometry, calculus, and even imaginary numbers. I set to challenge
      myself to implement one of those things from the ground up using nothing
      but pure SCSS, not even with the help of languages like Javascript or
      PHP.</p>

      <p>For hours, I sat, scouring at the computer; I nearly gave up hope until
      I had some kick from within. <strong>Et voilà!</strong> I've successfully
      completed my challenge and I chose to showcase a certain function out of
      all that I had tried implementing. The implementation in SCSS worked
      extremely well, but since there was no way to "print" the result to stdout
      as in most programming languages (e.g., Fortran:
      <code>print "(f9.6)", sin(x)</code>), I had to parse the output values of
      my implementation into some properties of certain HTML elements selected
      with good old CSS selectors, only so that they can create a visual
      representation of the output &mdash; a cartesian graph rotated <span
      class="math">&minus;&pi; / 4</span> radians.</p>

      <p>If you have not seen what <em>Thicc Curve</em> looks like, you
      definitely ought to see it before moving on to subsequent sections. Of
      course, you will need a browser running on a graphical environment and
      capable of displaying colour, which should describe most browsers in the
      market today. For your convenience, <a href="curve.html">here is the
        link</a>.</p>

      <p>This section has given you an overview of things you should or have
      probably already known upon close inspection of the inner-workings of the
      <em>Thicc Curve</em>, along with some background notes as well. In the
      next section, an analysis of the HTML code will be done and detailed.</p>

      <h1>The HTML code</h1>
      <p>By this time, you should have already known that there are 314
      intentionally empty <code>div</code> elements and that they are children
      of a parent <code>div</code> with an id of <code>plot-sin</code>. These
      are crucial clues one must take away so as to construct a key to decipher
      how the <em>Thicc Curve</em> is constructed. However, this is not the end
      game to the story; those clues can only explain half of the inner workings
      of the figure, not the whole thing. In this section, we'll link together
      the two clues and leave you with some ending key points to ponder
      about.</p>

      <div class="figure-container">
        <img src="images/inspection2.png" alt="A closer look at the HTML code of
        the Thicc Curve" />
        <p>A closer look at the HTML code of the Thicc Curve. (Author; Sep 3,
        2017)</p>
      </div>

      <p>Time to discuss our questions: Why are there <strong>exactly
        314</strong> empty <code>div</code> elements put in the code by
      design? Why is the parent <code>div</code>'s id named
      <code>plot-sin</code>?
      </p>

      <p>By 3rd grade, you've most likely learnt what <span
      class="math">&pi;</span> (Pi) is, its value, and its practicalities. It is
      the ratio of the circumference of any circle to the diameter of that same
      circle. It has been defined since Ancient Greek times and has been used
      in a number of formulae and calculations modelling properties pertaining
      to triangles, circles, spheres, pendulums, various other shapes, and many
      more. It is approximately equal to <span
      class="math">3.14159265359</span>. From here on in this section, 
      let <span class="math">q</span> be the quantity of empty <code>div</code>
      elements within the <code>div#plot-sin</code> parent. Isn't it interesting
      to notice that:</p>

      <div class="math">q &asymp; &pi; &middot; 100 (0 d.p.)</div>

      <p>By the end of middle school, you've most likely learnt your
      trigonometric functions, their inverses, reciprocals, and some of their
      indentities: <span class="math">sin(x) = 1 / csc(x) [where x =
        asin(sin(x))]</span>. By then, you've also most likely learnt some
      trigonometric identities and precomputed values for some predetermined
      inputs. Assuming we are working in radians, isn't it interesting to notice
      that:</p>

      <div class="math">sin(&pi;) &asymp; sin(q / 100) &asymp; 0</div>

      <p>Descriptively enough, the parent <code>div</code> containing all those
      empty <code>div</code>s has an id called <code>plot-sin</code>. It is
      indeed a good coding practice to name your divs according to what purpose
      they serve.</p>

      <p>Think about it for a second. This can only lead to one conclusion.
      although the height of each <code>div</code> in <code>div#plot-sin</code>
      is fixed to some constant, the width of each of them is the output value
      of the <span class="math">sin</span> function given some specific input.
      For each empty <code>div</code>, the <span class="math">sin</span>
      function is evaluated with input as the <span class="math">nth</span>
      occurrence of that such empty <code>div</code> within
      <code>div#plot-sin</code> divided by 100. This is basically the same as
      the plot of <span class="math">sin(x) : 0.01 &lt; x &lt; 3.14</span> but
      rotated by <span class="math">&minus;&pi; / 4</span> radians.
      </p>

      <p>Since CSS does not understand elements whose width or height is a
      negative value (e.g., you can never have a -5px-wide div) and we just want
      the first non-repeated part of the function's plot, thus there are
      exactly 314 empty <code>div</code>s (counting from the first empty
      <code>div</code> at 1) by design, because:</p>
      
      <div class="math">&forall;x &in; &real;
        [((1 / 100) &lt; x &lt; (q / 100)) &rArr; sgn(sin(x)) = 1]</div>

      <p>I don't understand what I just wrote there either. :p
      In other words, one of the infinitely many intervals over which <span
      class="math">sin(x) &gt; 0</span> is when <span class="math">0.01 &lt; x
      &lt; 3.14</span>. Notice that we are approximating the values of <span
      class="math">0</span> and <span class="math">&pi;</span> here based on the
      <span class="math">nth</span> occurrence of each empty <code>div</code>
      in <code>div#plot-sin</code> divided by 100.</p>

      <p>Now, you may have noticed that we have been adding and removing 2
      orders of 10 (i.e., 100) a lot when we interface between the <span
      class="math">nth</span> occurrence of each empty <code>div</code> in
      <code>div#plot-sin</code> and the input value to the <span
      class="math">sin</span> function. The obvious reason is that,
      although the <span class="math">sin</span> function being a
      mathematical function whose value is defined for all real
      numbers&nbsp; can handle any real number <span class="math">x :
      &minus;&infin; &lt; x &lt; &infin;</span>, one cannot have a fractional
      amount of HTML elements. Surely, I can have 5 <code>div</code>
      elements on my page and style them accordingly using CSS, but what
      does it even mean to have 3.14 <code>div</code> elements on my page?! Does
      it mean that I have 3 <code>div</code>s and an unclosed <code>div</code>
      element whose content is exactly 14% done? What we're basically doing is
      sizing up the input for the sake of HTML and sizing them down for the sake
      of the <span class="math">sin</span> function when needs be. Therefore,
      <span class="math">q</span> is an integer.
      </p>

      <p>As for the rainbow colour spread over the <code>div</code>s? Well, this
      is a relatively simple question to answer. Imagine a completely circular
      colour wheel from red to magenta or the HSL colour wheel where <span
      class="math">h</span> goes from 0 to <span
      class="math">2&pi;</span> radians and <span class="math">s, l = 0.5
      </span>. Then, we divide that colour wheel into a pizza or cake of <span
      class="math">q</span> slices.
      As a result, each empty <code>div</code> progressively from top to bottom
      gets its fair share of the colour wheel and each one of them gets a
      different colour. Details on how this is done in SCSS will be looked at in
      the SCSS section.</p>

      <p>In this section, we took a look at the clues given by the HTML code and
      made some inferrences to figure out the theory behind rendering the
      <em>Thicc Curve</em>. However, the challenge now is to implement the
      crucial mathematical function being used to define the figure's appearance
      (the <span class="math">sin</span> function) using nothing but SCSS. The
      SCSS preprocessing language lacks the many capabilities of mathematics and
      only gives a "few" binary operations.
      How do we go about and implementing a trigonometric function inside such a
      limited environment? The next section describes the problem of why it is
      not easy to do in SCSS and the theory behind the solution to that problem.
      The section thereafter describes the practical applications of the theory
      in SCSS.</p>

      <h1 id="primer">Defining the sine function</h1>
      <p>SCSS/SASS (Sassy Cascading StyleSheets / Syntactically Awesome
      StyleSheets) is a great extension and syntactic sugar to traditional CSS.
      It is used for styling large web projects, aiming to make styling more
      powerful while minimalizing the clutter and redundancy in traditional CSS.
      As a result, SCSS has support for some basic mathematical operations:
      addition (<code>+</code>), subtraction/unary sign (<code>-</code>),
      multiplication (<code>*</code>), division (<code>/</code>), and modulo
      (<code>%</code>); some programming features: for loops
      (<code>@for</code>), each loops (<code>@each</code>), decision controls
      (<code>@if/"@else if"/@else</code>), functions (<code>@function</code>),
      and variables (<code>$var</code>); and some object-oriented programming
      features: mixins (<code>@mixin</code>). Each one of these alone is not
      enough to extend to further, more complex mathematical calculations, let
      alone any trigonometric functions. However, with the right permutation of
      a subset of them, one can implement algorithms which serve
      the same purpose as several existing and complex mathematical functions,
      including the <span class="math">sin</span> function. In this section, I
      will go into the theory as to how those SCSS language features, albeit
      limited, can be used to implement an algorithm that approximately serves
      the same purpose as the <span class="math">sin</span> function within some
      very reasonable degree of accuracy, and how to implement such an algorithm
      into Fortran-flavoured pseudocode. Some other smaller algorithms will also
      be implemented and used.</p>

      <p>Before we really go into detail, I'd like to insert some recap in
      mathematics for those who need to reconsolidate their mathematical skills.
      In the following 2 subsections, we'll go through all the math ever taught
      since middle school upto high school that relates to what we're doing to
      render <em>Thicc Curve</em>. Then, after those two subsections, we'll
      follow the regular course that we planned out in the previous paragraph.
      If you think you know enough of the math, feel free to skip the following
      subsections.</p>

      <p>One more note, I, the author, have never been really good at
      mathematics and science. I only know a little and I still can't match my
      friends' mathematical skills. I remember that I struggled so much at math
      when I was a child that my mom sent me to various after-school math
      classes and she would get really disappointed about me most of the
      time. So, if you see any errata in here, please feel free to correct them
      in the page's HTML source file on Github.</p>

      <h2>Basic math primer</h2>
      <p>By the end of middle school, you have probably learnt about two
      significant operations: exponents (<span class="math">5<sup>3</sup> =
        125</span>) and factorials (<span class="math">5! = 120</span>). Long
      before that, you have also learnt some mathematical constants with
      special meanings, like <span class="math">&pi;</span> and
      <span class="math">e</span>. By the end of the first year in high school,
      you have probably learnt about differential calculus. In this subsection,
      we'll have a quick recap of the 4 of those key concepts one-by-one,
      dividing this subsection into 4 parts.</p>

      <p>Here in the first part of this subsection, let's take a look at
      exponentiation. In a nutshell, exponentiation is simply a shortcut to
      convey the notion of <em>compounded multiplication</em>.
      Therefore, instead of having to write <span
      class="math">5 &middot; 5 &middot; 5 = 125</span>, you write <span
      class="math">5<sup>3</sup> = 125</span>, which means to multiply <span
      class="math">5</span> by <span class="math">1</span>,
      <span class="math">3</span> times compounded.
      This not only makes you look a lot cooler but also saves paper space and
      therefore saves the trees and the earth and everyone is happy. We all want
      to be happy, right? Let's take a look at some examples.</p>

      <div class="flmath">
        <ul>
          <li>2<sup>4</sup> = 1 &middot; 2 &middot; 2 &middot; 2 &middot; 2 = 16
          </li>
          <li>7<sup>3</sup> = 1 &middot; 7 &middot; 7 &middot; 7 = 343</li>
          <li>10<sup>5</sup> = 1 &middot; 10 &middot; 10 &middot; 10 &middot; 10
            &middot; 10 = 100,000</li>
          <li>4<sup>0</sup> = 1 &hArr; &forall;x &in; &real; [x &ne; 0 &rArr;
            x<sup>0</sup> = sgn(x)]</li>
          <li>4<sup>1</sup> = 4 &hArr; &forall;x &in; &real; [x<sup>1</sup> = x]
          </li>
          <li>0<sup>0</sup> = indeterminate (lim x &rarr; 0 [x<sup>0</sup>] = 1)
          </li>
        </ul>
      </div>

      <p>The first three equations are intuitive enough, but the last two are
      equations that just need some getting used to. Don't worry too much,
      though, you aren't alone: I've come up with some reasoning patterns for
      you in the aforementioned equations.</p>

      <p>Now, I did mention that, "exponentiation is compounded
        multiplication". Well, you may have already learnt from 3rd grade
      that "multiplication is compounded addition", right? In some cases,
      I think it's better to think of exponentiation that way and introduce the
      concept of <strong>hyperoperation</strong>, which is how we think of
      "compounding" operations together. Following is a list of common
      hyperoperations that we know well. This is literally part of the backbone
      of all the mathematical operations you know.</p>

      <div class="flmath">
        <ul>
          <li><strong>Hyperoperation 0 (succession):</strong>
            succ(1) = 2</li>
          <li><strong>Hyperoperation 1 (addition; compounded
              succession):</strong> 3 + 2 = succ(succ(3)) = succ(succ(succ(2)))
          = 5</li>
          <li><strong>Hyperoperation 2 (multiplication; compounded
              addition):</strong> 3 &middot; 4 = 3 + 3 + 3 + 3 = 4 + 4 + 4 = 12
          </li>
          <li><strong>Hyperoperation 3 (exponentiation; compounded
              multiplication):</strong> 4<sup>3</sup> = 4 &middot; 4 &middot; 4
          = 64</li>
          <li><strong>Hyperoperation 4 (tetration; compounded
              exponentiation):</strong> <sup>3</sup>5 =
            ((5<sup>5</sup>)<sup>5</sup>)<sup>5</sup> = 235098870164457501593747
            3074444491355637331113544175043017503412556834518909454345703125
          </li>
        </ul>
      </div>

      <p>I know things get really crazy at tetration: numbers grow very fast
      there. That's okay, you don't have to understand it; we are not using it
      to render <em>Thicc Curve</em>, but we are using lots of exponentiation.
      </p>

      <p>Now, onwards to the second part of this subsection: factorials. They
      are like exponentiation in that they compound together some
      multiplications; however, the difference is that each term is reduced by
      <span class="math">1</span> until the multiplicand reaches <span
      class="math">1</span>. To clarify, <span class="math">5! = 5 &middot; 4
      &middot; 3 &middot; 2 &middot; 1 = 125</span>. This operation is useful in
      fields like number theory and combinatorics; for example, the number of
      ways a set of <span class="math">n</span> cards can be arranged in a
      unique order is <span class="math">n! = n &middot; (n &minus; 1) &middot;
      (n &minus; 2) &middot; &hellip; (until n &minus; k = 1)</span>, so if
      there are 3 cards in the set, <span class="math">3! = 3 &middot; 2
      &middot; 1 = 6</span> ways. Let's clarify further.</p>

      <div class="flmath">
        <ul>
          <li>6! = 6 &middot; 5 &middot; 4 &middot; 3 &middot; 2 &middot; 1 =
            720</li>
          <li>1! = 1</li>
          <li>0! = 1 <strong>(wtf)</strong></li>
        </ul>
      </div>

      <p>Yes, the first two equations are obvious, but the last one may seem
      absolutely unreasonable. It is just how math works, and so <em>C'est la
        vie!</em> I'm kidding. The intuition is that you should consider how
      many ways there are to arrange a set of 0 cards. Since there is only 1 way
      of arranging 0 cards: an absent of cards, an empty playing table, ergo
      <span class="math">0! = 1</span>. If you shout a number loudly enough, you
      will <em>almost always</em> get back a number that is larger than that
      which you shouted (the exceptions are <span class="math">1</span> and
      <span class="math">2</span>).</p>

      <p>To the third part of this subsection, we have some constants with
      special meanings that you should already know about in mathematics.  The
      following is a non-exhaustive list of those that will help in reading this
      document. For a more thorough description and more exhaustive list,
      consult a proper mathematical reference.</p>

      <div class="flmath">
        <ul>
          <li>&pi; &asymp; 3.14159265359 (12 d.p.)</li>
          <li>e &asymp; 2.718281828459 (12 d.p.)</li>
        </ul>
      </div>

      <p>&pi; is the ratio of the circumference of any circle to the diameter of
      that same circle. <span class="math">e</span> is the natural number that
      has something to do with compound interests; I hate money, so I don't
      really know what <span class="math">e</span> really is either.</p>

      <p>Finally at the fourth part of this subsection, we'll have a look at
      derivatives from differential calculus, which are used extensively in the
      next subsection.</p>

      <p>Imagine a few internet service providers (ISPs) in your area and they
      all charge their customers at a fixed price per hour + an initial one-time
      registration fee. It's terrible pricing, I admit, but they are your only
      choices of getting connected to the Internet. Let us explore each of our
      choices:</p>

      <div class="flmath">
        <ul>
          <li><strong>ISP Alpha:</strong> $5 / hour + $2 initial fee</li>
          <li><strong>ISP Beta:</strong> $7 / hour + $0.5 initial fee</li>
          <li><strong>ISP Gamma:</strong> $3 / hour + $9.99 initial fee</li>
        </ul>
      </div>

      <p>Now, suppose you really need to get to the Internet and see if your
      crush has replied, but you still want to get your accounting jargon right
      and save as much money as possible, perhaps you would choose to analyze
      how much each ISP will be charging you as the hours of Internet usage goes
      by. So, you decide to plot a chart with the y-axis in dollars and the
      x-axis in hours of usage. However, while doing so, you notice that the
      term <span class="math">$5 / hour</span> is simply the ratio of the amount
      of money charged to the number of hours, so using the Internet for 10
      hours would incur a charge of $50. In charting terms, the "ratio of the
      amount of money charged to the number of hours" is the "ratio of the
      change in y to the change in x" or the "rise over run".
      You'll quickly see how this makes sense by looking at the chart which you
      plotted: the line goes 5 units up when it nudges 1 unit to the right.</p>

      <p>Now, it's all nice and dandy when your ISP charges you at a fixed rate.
      It makes it very easy to calculate what a meanie they are. The plot is
      that of a straight line and values on a straight line increase or decrease
      at a constant rate. If you chose <strong>ISP Alpha</strong>, they would
      always charge you $5 for any given hour at a regular rate. So, the rise
      over run (the ratio of the change in y to the change in x) is always going
      to be the same on all plotted points of the chart.</p>

      <p>Okay, let us get serious. When I was a child, my family would take me
      on road trips along rugged terrains by a river. Those terrains were full
      of large rocks, but luckily we had a jeep that could persevere through
      those types of terrains. I think we have all gone on road trips as a child
      before, right? So, let's stick to this analogy. Now, back then, I was a
      very curious child: I would look at the speedometer with such fascination.
      However, I noticed something that shook me with great dissatisfaction.
      On straight, paved roads, the meter would accurately say that we are going
      at 40 kph (40 kilometers of road covered within 1 hour); however, when we
      bumped into a small pothole on the road, the meter still showed that we
      were going at the same speed as before we bumped into the pothole.</p>

      <p>Just think about it for a second, if the jeep falls (even by 3
      centimetres) down a small pothole on the road and climbs up from it again
      (again, even by another 3 centimetres), the distance of going down and up
      will add up to 6 centimetres. Now ask yourself, are these 6 centimetres
      of pothole height the actual distance of the actual road?</p>

      <p>The answer is <em>No</em>, because at that instant of time when the
      jeep was falling down the 3 centimetre-high pothole, the jeep was not
      moving forwards, but instead: moving downwards and the acceleration
      provided by gravity. Now, shouldn't it be the case that the speed
      displayed on the speedometer drop to almost 0? That's a question I had
      always been wondering during my childhood. The answer is that, because
      falling down that pothole only lasted for 500 milliseconds, the meter was
      not fast enough to register the change in speed, so the speed stays at 40
      kph.</p>

      <p>Road users do not need fast-reacting speedmeters that behave like
      high-end oscilloscopes. They need something accurate enough over a drive
      of 2 seconds just so as to avoid getting a speeding ticket from a police
      officer. It is a different story for mathematicians who drive on the
      road of numbers: they just need to know with great precision the rate of
      change.</p>

      <p>So yes, the speedometer was correct. <strong>On average,</strong> we
      were driving on the road at 40 kph. Therefore, we reached our destination
      of 80 km away within <em>approximately</em> 2 hours even after bumping
      into a few potholes down the road. However, we never really did sustain
      this speed of 40 kph all the time. We had to climb hills and drive down
      potholed roads. Those terrain features decreased our distance covered by a
      bit. The speed right at when the jeep drove down a pothole
      would not be equal to 40 kph. This new speed at which the jeep drove down
      a pothole is so fast that the speedometer could not detect, but
      differential calculus can help us look back and at that and render the
      instantaneous rate of change in y (distance) over change in x (time) or
      the change in speed (kilometers over hour).</p>

      <p>The fact that the speedometer was not accurate enough, I was
      practically crying inside. :(</p>

      <p>When we would like to analyze such complex behaviour or changes
      thereof, we model it as a function, plot it, and
      <strong>differentiate</strong> it to find the instantaneous rate of the
      change in y over the change in x. So, if we let
      <span class="math">f(x)</span> model the distance
      covered by the jeep as a function of time in hours, we can find the change
      in distance covered over the change in time by differentiating the entire
      function to find the <strong>derivative</strong> of that such
      function.</p>

      <p>In calculus-speak, the derivative of the function <span
      class="math">f(x)</span> is <span class="math">f'(x)</span> ("f prime of
      x"): a new function that details the rates of change of the original
      function.</p>

      <p>Let's suppose I wanted to find the speed the jeep was going when it
      fell into a pothole 1.125 hours into the journey. If I evaluate <span
      class="math">f(1.125)</span>, I get the total distance covered from home
      to pothole; if I evaluate <span class="math">f'(1.125)</span>, I get the
      instantaneous rate of change in y over change in x in the plot of <span
      class="math">f(x)</span> when the jeep is right at the pothole. In
      calculus, we calculate the rate of instantaneous change in y over change
      in x (<span class="math">dy/dx</span>) like so:</p>

      <div class="math">
        dy/dx = lim c &rarr; 0 [(f(x + c) &minus; f(x))/c]
        <br />f'(x) = lim c &rarr; 0 [(f(x + c) &minus; f(x))/c]
      </div>

      <p>Basically, we are dividing the change in y by the change in x for
      smaller and smaller values of x approaching 0. As we get closer and closer
      to <span class="math">x = 0</span>, the instantaneous rate of change we
      can calculate gets better and better for that point. Surely, we did get to
      our destination 80 km away from home within about 2 hours because the
      ratio of the change in y (km) to the change in x (hours) is <span
      class="math">40/1</span>. However, we had new ratio of y to x at the
      pothole we bumped in 1.125 hours into the trip, right?</p>

      <p>The derivative of a function can have a derivative of its own too! It's
      basically the derivative of a derivative: the changes of the changes of a
      model. In our analogy, the function represents the amount of distance
      covered as a function of time, the derivative thereof represents the speed
      (change in distance) of the vehicle as a function of time, and the
      derivative of that derivative would be the acceleration (change in speed)
      as a function of time. The derivative of the derivative of the function
      <span class="math">f</span> is denoted as <span class="math">f''(x)</span>
      (f prime prime of x) or <span class="math">f<sup>(2)</sup>(x)</span>.
      Derivatives of higher orders are generally written the latter way: <span
      class="math">f<sup>(3)</sup>(x), f<sup>(4)</sup>(x), f<sup>(5)</sup>(x),
      &hellip;</span></p>

      <p>Relative to other disciplines within mathematics, calculus is a very
      hard topic to explain and understand without visual representations and
      real-life counseling (literally). I suggest that more guidance on calculus
      be looked at if needs be. This concludes our calculus recap needed to
      understand the rest of the document, especially the Maclaurin series.</p>

      <p>In the next subsection, we will be looking at the Maclaurin series,
      which requires a good understanding of all the things we've recapped in
      this subsection.</p>

      <h2>The Maclaurin series</h2>
      <p>By the end of middle school, you will have probably learnt about
      functions (<span class="math">f(x)</span>) and how they can be plotted on
      a cartesian plane (<span class="math">y = f(x)</span>). Some of them are
      cool, like <span class="math">1/x, ax<sup>2</sup> + bx + c, sin(x), ln(x),
        erf(x), &hellip;</span>; others are kind of boring, like
      <span class="math">y = 64, mx + c, &hellip;</span>. Almost every function,
      including the ones described beforehand, can be expanded into an
      (in)finite Taylor Series; that is to say, almost every function can be
      written in another form called the Taylor Series. Such an expansion is
      called the Taylor Expansion. A type of Taylor Series called the Maclaurin
      Series is the case which we work with the function's value and its
      higher-order derivatives' values at input <span class="math">x = 0</span>.
      In this subsection, we'll look at a basic overview and recap of the
      Maclaurin series taught in high school calculus.
      </p>

      <p>Much in the same way as there are infinitely many natural numbers and
      even more infinitely many rational numbers (try counting: 1, 2, 3, 4, 5;
      see how far you can count before you get tired, only to realize that the
      numbers never end), there are infinitely many functions in mathematics,
      each of which have their own unique feature when plotted on the cartesian
      plane. Likewise, much in the same way as those infinitely many rational
      numbers can be expressed in many different ways: decimals (3.125),
      percentages (312.5%), permillages (3125&permil;), mixed fractions (3
      1/8), improper fractions (25/8), and all appearances of unsimplified
      fractions (50/16, 100/32, &hellip;), all of which express the same real
      quantity; almost all functions can be expressed in many different ways:
      <span class="math">(1+x)<sup>3</sup></span> (the "KISS" way), 
      <span class="math">1 + 3x + 3x<sup>2</sup> + x<sup>3</sup></span>
      (the "im so smart" way). As such, much as "certain" rational numbers can
      go on forever when expanded to decimals: <span class="math">1/3 =
        0.333 &hellip; (ad infinitum)</span>, functions can also behave in
      the same way when expanded: <span class="math">e<sup>x</sup> = 1 + x +
        x<sup>2</sup>/2 + x<sup>3</sup>/6 + x<sup>4</sup>/24 + x<sup>5</sup>/120
        + &hellip; (ad infinitum)</span>. Furthermore, much as non-rational real
      numbers can only be expressed exactly by their symbols: <span
        class="math">e &ne; 2.718282, &pi; &ne; 22/7</span>; certain functions
      cannot be expressed in another way and must stay true to their written
      definitions: the Weierstrass function is a notable example of a function
      that cannot be expanded and must stay within its written definition for it
      to be exact.  </p>

      <p>When we learnt math in school, we were taught methods on how to convert
      decimals, percentages, and fractions amongst each other. It is just
      writing the same quantity in a different way. Just as there is a method to
      do so with rational quantities, there is also a method to write one same
      "rational" function in a different way. <strong>Keep in mind</strong> that
      just as some irrational but real quantities like <span
      class="math">&pi;</span> cannot be expressed exactly as anything else but
      their symbol, some functions cannot be expressed as anything else but
      their written definition. Now, Following this paragraph is the method to
      rewrite any function <span class="math">f(x)</span> as an (in)finite
      Maclaurin's series:</p>

      <div class="math">f(x) = f(0) + f'(0)x +
        f<sup>(2)</sup>(0)(x<sup>2</sup>/2!) +
        f<sup>(3)</sup>(0)(x<sup>3</sup>/3!) +
        f<sup>(4)</sup>(0)(x<sup>4</sup>/4!) + &hellip; (ad infinitum)
      </div>

      <p>Here are the important takeaways:</p>
      <ol>
        <li>Notice that we will only ever work
      with the function and the function's higher order derivatives at <span
      class="math">x = 0</span>. This is what defines the Marclaurin series: it
      is a type of Taylor Series where we work with functions when <span
      class="math">x = 0</span>. If we do ever need to work with functions whose
      value is not defined at <span class="math">x = 0</span>, we can simply add
      a <span class="math">+ 1</span> term, and so find we the Maclaurin series
      of <span class="math">f(1 + x)</span>. A case in point is the Maclaurin
      series of <span class="math">(1 + x)<sup>3</sup></span>.</li>
        
        <li>Notice that I
      keep writing the word <em>"<strong>(in)</strong>finite"</em> and not
      literally <em>"infinite"</em>. This is because the Maclaurin series of
      certain functions turn out not to be infinite even though the Maclaurin
      series is defined to be infinite. A case in point is the Maclaurin Series
      of polynomials like <span class="math">ax<sup>2</sup> + bx + c</span>, one
      of whose high-order and subsequently higher-order derivatives turns out to
      be <span class="math">0</span>, ergo making the coefficients of each
      subsequent term <span class="math">0</span>.</li>
        
        <li>If a Maclaurin series of a function is
      infinite, although in theory the infinite series is the <em>exact</em>
      representation of the function, in practice, we can only ever get an
      approximation of that such function. It is not something that troubles a
      theoretical turing machine, but it does trouble our imperfect turing
      machines (computers and calculators alike) due to the finite memory and
      time we have when comparing to the infinite memory and time required by
      the theory in order for it to work. However, keep in mind that even in
      practice, the more we expand our function, the closer we get at the
      function's exact integrity.
      </li>

      <li>Mathematicians will often call <em>the act of finding a series
          representation of a function</em>: <em>expanding the function</em>.
        Intuitively enough, this is because the series of a function is often
        written in a longer form than the function, and is more like an indirect
      way of finding the values of that such function.</li>
      </ol>

      <p>So, you have just seen for yourself how a simple series can be used to
      express almost any function in math, we generally only ever have to
      work with the function and its higher-order derivatives at 0, and the more
      we expand the more accurate a representation of the actual function we
      get. Isn't it just fascinating?</p>

      <p>I am not saying that the Maclaurin series of any function is the
      <em>exact</em> representation, although in theory it is and there is proof
      for it somewhere else. It will never be practically exact because we are
      finite beings, our legacy and machines do only as good a job as extending
      the finity and approximating the infinite. Therefore, a practical turing
      machine (computers) will never get exactly close to a function when
      evaluating a Maclaurin series. However, the further we expand the series
      and the further the computational undertaking is done, the more accurate
      our representation is going to get.</p>

      <p>Now, it is time for some examples where we expand some well-known
      functions into their Maclaurin series equivalent. We'll start with simple
      finite expansions before moving on to more complicated ones with infinite
      expansions.</p>

      <div class="flmath">
        <ul>
          <li><strong>linear:</strong> 2x + 3 = 3 + 2x</li>
          <li><strong>polynomial:</strong> 3x<sup>2</sup> + 4x + 5 = 5 + 4x +
            3<sup>2</sup></li>
          <li><strong>polynomial:</strong> (1 + x)<sup>5</sup> = 1 + 5x +
            10x<sup>2</sup> + 10x<sup>3</sup> + 5x<sup>4</sup> + x<sup>5</sup>
          </li>
          <li><strong>exponential:</strong> e<sup>x</sup> = 1 + x +
            x<sup>2</sup>/2 + x<sup>3</sup>/6 + x<sup>4</sup>/24 + &hellip; (ad
          infinitum)</li>
          <li><strong>logarithmic:</strong> ln(x) = x &minus; x<sup>2</sup>/2 +
            x<sup>3</sup>/3 &minus; x<sup>4</sup>/4 + x<sup>5</sup>/5 &minus;
            &hellip; (ad infinitum)</li>
          <li><strong>geometric:</strong> 1/(1 &minus; x) = 1 + x + x<sup>2</sup> +
            x<sup>3</sup> + x<sup>4</sup> + &hellip; (ad infinitum)</li>
          <li><strong>wicked:</strong> erf(x) = 2x/sqrt(&pi;) &minus;
            2x<sup>3</sup>/(3 sqrt(&pi;)) + x<sup>5</sup>/(5 sqrt(&pi;)) &minus;
            x<sup>7</sup>/(21 sqrt(&pi;)) + &hellip; (ad infinitum)</li>
        </ul>
      </div>

      <p>Well, there are countless more functions that can be expanded using the
      Maclaurin series (including trigonometric functions), but I think this is
      enough to get you started.</p>

      <p>Notice that some functions, when expanded, give the same function with
      terms in reverse. Well, I promise that when I did those expansions, I
      followed the exact methods of expanding using the series. We ended up with
      the same function and we should be happy with that, right? I mean, make
      life simple when necessary please. :P Also, some expansions do have really
      weird coefficients involved, but this is because they have been simplified
      with the help of some obvious algebraic tricks, so deep inside, they
      aren't weird at all.</p>

      <p>I've already said that our function representation gets more and more
      accurate the more we expand the function. This implies that there is some
      kind of growth in accuracy: our approximation is growing into and
      morphing around the function's actual values. This is actually how it
      works. If you would like to see an animation of how the Taylor Series
      approximations get better and better as we expand further and further,
      there is <a
      href="https://en.wikipedia.org/wiki/Taylor_series#/media/File:
      Exp_series.gif" target="blank">this one</a> from Wikipedia. You will see
      that it really visually morphs and ties itself around the actual function.
      </p>

      <p>Yes, they look crazy and some of them seem really wicked and outlandish
      as if they would go to infinity in the end, but trust me: they will
      converge at some point.</p>

      <p>In this subsection, you've learnt about the Maclaurin series. After
      this, we'll get back into the scope of the section and define the <span
      class="math">sin</span> function using the series and program it into
      pseudocode. We'll also program some other required mathematical features
      into pseudocode as well.

      <p>Before leaving this subsection, check out <a
      href="https://www.khanacademy.org/math/calculus-home/series-calc/taylor-series-calc/v/maclauren-and-taylor-series-intuition"
      target="_blank">Sal Khan's explanation on the Maclaurin Series</a> if you
      need a more detailed primer.</p>

      <h2>Implementation</h2>
      <p>It is now time to continue on our current path and explore how we can
      the <span class="math">sin</span> function in SCSS. Remember that SCSS has
      these basic mathematical operations: addition (<code>+</code>),
      subtraction (<code>-</code>), multiplication (<code>*</code>), division
      (<code>/</code>), and modulo (<code>%</code>); and some general logical
      and control flow constructs. The challenge is to implement a complex
      trigonometric function like <span class="math">sin</span>. How does one do
      that in SCSS?</p>

      <p>Well, first we could start by expanding the <span class="math">sin
      </span> function into an infinite polynomial expansion using the Maclaurin
      series. Looking at the formula for the series, it appears that we have to
      find the derivatives and the higher-order derivatives of the function we
      want to expand, find their values at <span class="math">x = 0</span> and
      use those values as the coefficients for the terms of our expansion.
      Here's a list of the first 4 orders of derivatives of the function with
      the function itself (0th order) included for comparison:</p>

      <div class="flmath">
        <ol start="0">
          <li>f(x) = sin(x)</li>
          <li>f'(x) = cos(x)</li>
          <li>f<sup>(2)</sup>(x) = &minus;sin(x)</li>
          <li>f<sup>(3)</sup>(x) = &minus;cos(x)</li>
          <li>f<sup>(4)</sup>(x) = sin(x)</li>
          <li>&hellip;</li>
        </ol>
      </div>

      <p>It can be seen clearly that the derivative loops back to the 0th order
      derivative (original function) <span class="math">sin(x)</span> on the 4th
      order of derivative, which should imply that subsequent orders of
      derivatives would be recurring in a loop going on pretty much forever.
      This is a clear indicator that the <span class="math">sin(x)</span>
      function is a function whose derivatives can be extracted indefinitely;
      therefore, the polynomial expansion should be infinite.</p>

      <p>There's nothing to be remembered here. Basically, each derivative we
      take of the <span class="math">sin</span> function incurs a phase shift of
      <span class="math">&pi;/2</span> radians onto the function before it.</p>

      <p>However, since SCSS is a preprocessor language for running on a finite
      turing machine, we will have to stop evaluating our polynomial expansion
      at a certain reasonable point. Thus, it will not be the exact
      representation of the <span class="math">sin</span> function, but it will
      be extremely close: so close that we can ignore any minute errors.</p>

      <p>When constructing the Maclaurin expansion of the function given these
      derivatives, we will have to evaluate each function in the list above when
      <span class="math">x = 0</span> and take their output values as the
      coefficients of the terms in the series. Here is a list of the 4 orders of
      derivatives of the function with the function itself (0th order) included
      for comparison <strong>when evaluated at <span class="math">x =
          0</span></strong>:</p>

      <div class="flmath">
        <ol start="0">
          <li>f(0) = sin(0) = 0</li>
          <li>f'(0) = cos(0) = 1</li>
          <li>f<sup>(2)</sup>(0) = &minus;sin(0) = 0</li>
          <li>f<sup>(3)</sup>(0) = &minus;cos(0) = &minus;1</li>
          <li>f<sup>(4)</sup>(0) = sin(0) = 0</li>
          <li>&hellip;</li>
        </ol>
      </div>

      <p>Finally, we map the output values of those functions as coefficients
      over the terms in our series. We then have the infinite polynomial
      expansion of the <span class="math">sin</span> function that works for any
      input values <span class="math">x</span> of that function:</p>

      <div class="math">
        sin(x) = x &minus; x<sup>3</sup>/6 + x<sup>5</sup>/120 &minus;
        x<sup>7</sup>/5040 + x<sup>9</sup>/362880 &minus;
        x<sup>11</sup>/39916800 + &hellip; (ad infinitum)
      </div>

      <p>It may not be so obvious as to where the coefficients obtained by the
      function and derivatives we evaluated earlier go to. However, notice
      that the coefficients turns out to be 0 once in two times and anything
      multiplied by 0 basically signifies a discarded term, so that such term is
      not included in the series, ergo half of the series is eliminated.
      Also, the absolute values of the coefficients
      are only ever going to be either 0 or 1; in algebra, we don't
      generally add the exact value of the coefficient to a term when <span
      class="math">1</span> happens to be the coefficient. If the coefficient is
      <span class="math">&minus;1</span>, the coefficient is not added either,
      but the sign of the term is reversed.</p>

      <p>The large numbers dividing the <span class="math">x</span>:s are
      basically factorials that have already been evaluated. Nothing surprising
      right there at all. So, <span class="math">5040 = 7!, 362880 =
        9!</span>. Oftentimes, I just have trouble keeping things unevaluated,
      you know what I mean? ;) I just can't help but evaluating them into their
      exact values whenever I can.</p>

      <p><strong>No, we will never let SCSS find the polynomial expansion of any
        function <span class="math">f(x)</span>.</strong> However, we will let
      SCSS do the work of plugging in different values of <span
      class="math">x</span> into the series we've just
      obtained and doing basic arithmetic to obtain the
      approximate but reasonably accurate result of the <span class="math">
        sin</span> function. Although a theoretical turing machine can evaluate
      the Maclaurin expansion indefinitely and get the exact result, our
      computers are finite turing machines which cannot. Therefore, it is not
      possible to let the SCSS preprocessor evaluate the polynomial until we
      approach infinity: that would take forever, literally. We need to limit
      our evaluation to a reasonable degree, and for some reason, I chose to
      limit series evaluation to <span class="math">128</span>; this means that
      only <span class="math">128</span> terms will be evaluated by the computer
      before stopping there. Thankfully enough, this is enough to approximate
      the <span class="math">sin</span> function with a lot more precision than
      we would ever need.</p>

      <p>Also, a bit of a sidenote: I have tired coercing the SCSS preprocessor
      into evaluating the expansion at greater amount of terms than <span
      class="math">128</span>. However, it seems that doing so caused a
      floating point overflow error on the computer; thus, this is a technical
      constraint by which we are bounded.</p>

      <p>We have been doing a lot of math.
      Now, it's time to visualize all this as pseudocode and see the series
      evaluation function come to life:</p>

      <pre><code>
        ! Preconditions:
        !       x &in; &real;
        !       serieslimit &in; N (within a reasonable, machine-sized amount)
        function sin(x, serieslimit=128)
          real :: result ! To store our intermediate calculations.

          result = x

          for (i = 1; i &lt;= serieslimit; i++)
            result = result + (-1)<sup>i</sup> * x<sup>(2 &middot; i + 1)</sup> / (2 * i + 1)!
          end for

          return result
        end function
        ! Postconditions:
        !       &forall;x &in; &real; [-1 &le; sin(x) &le; 1]
        !       &forall;x &in; &real; [sin(x) &in; &real;]
      </code></pre>

      <p>The function <code>sin(x, serieslimit)</code> has 2 formal
      parameters:</p>
      
      <ul>
        <li><code>x</code> &mdash; the input being parsed into 
        the <span class="math">sin</span> function awaiting evaluation.</li>
        <li><code>serieslimit</code> (optional) &mdash; how far
          down the polynomial expansion we should evaluate. (default: 128)</li>
      </ul>

      <p>Since this is pseudocode useful for describing algorithms, by no means
      is this standard Fortran code. As pseudocode, it does run perfectly in my
      head and it is very reasonable enough. Let's take a look at the
      mathematical definition of our newly programmed <code>sin</code>
      function. You will notice that it is not an infinite polynomial series,
      but is bounded up to 129 terms (128 terms by the for loop and 1 <span
      class="math">+ x</span> term). The reason for such a boundary has already
      been discussed.</p>

      <div class="math">
        <code>sin(x)</code> = x &minus; x<sup>3</sup>/6 + x<sup>5</sup>/120
        &minus; x<sup>7</sup>/362880 + x<sup>9</sup>/362880 &minus;
        &hellip; + x<sup>257</sup>/257!
      </div>

      <p>Right now, we have our algorithm that can be implemented directly in
      pretty much all the programming languages ever to exist out there.
      However, the pseudocode features two mathematical operations that are not
      implemented in SCSS: exponents and factorials. It does not mean that we
      cannot ever evaluate the polynomial expansion in SCSS, but it does mean
      that we have to implement those basic mathematical operations ourselves.
      This can be done by creating one function for each of the operation we are
      to implement.</p>

      <p>To begin with, let's start with the exponentiation operation. By now,
      you should already know that exponentiation is <em>compounded
        multiplication</em> where the same number is multiplied repeatedly by
      itself some number of times. Admittedly, this is not the most
      mathematically vigourous definition of exponentiation: it fails to explain
      the notion of <span class="math">3<sup>sqrt(2)</sup></span> and the
      likes thereof (how does one justify multiplying 3 by itself <span
      class="math">sqrt(2)</span> times?). Luckily for us, we need not implement
      a vigourous function to represent exponentiation exactly by its formal
      definition: we can just do it the informal, introductory, and crude way
      we've previously mentioned. The following is the algorithm for
      exponentiation, defining it nonvigourously.</p>

      <pre><code>
        ! Preconditions:
        !       b &in; &real;
        !       e &in; N
        function pow(b, e)
          real :: result ! To store our intermediate calculations.

          result = 1

          for (i = 1; i &lt;= e; i++)
            result = result * b
          end for

          return result
        end function
        ! Postconditions:
        !       &forall;x &in; &real; &forall;y &in; N [pow(x, y) &in; &real;]
        !       &forall;x &in; &real; [pow(x, 0) = 1]
        !       &forall;y &in; N [pow(0, y) = 0]
      </code></pre>

      <p><code>pow(b, e)</code> has 2 formal parameters:</p>

      <ul>
        <li><code>b</code>: the real-valued base of the exponent.</li>
        <li><code>e</code>: the integer-valued power to which the base must be
          raised.</li>
      </ul>

      <p>And to top if off, let's implement the factorial operation. By now, you
      should know what factorials are and some of their "unusual" properties at
      first glance in the primer described somewhere before this. Unlike
      exponentiation, the behaviour of the factorial operation is much simpler
      to describe and we only ever need it this simple in our use case. So, this
      should be a near-formal definition of factorials, if not the formal
      definition thereof. The following is the algorithm for factorials.</p>

      <pre><code>
        ! Preconditions:
        !       n &in; N
        function factorial(n)
          integer :: result ! To store our intermediate calculations.

          result = 1

          for (i = 2; i &lt;= n; i++)
            result = result * i
          end for

          return result
        end function
        ! Postconditions:
        !       &forall;n &in; N [factorial(n) &in; N &#x22c0; factorial(n) &gt; 0]
        !       &forall;n &in; N [n &ne; 1 &#x22c0; n &ne; 2 &rArr; factorial(n) &gt; n]
      
      </code></pre>

      <p><code>factorial(n)</code> has 1 formal parameter:</p>

      <ul>
        <li><code>n</code>: the integer-valued power of which to compute the
          factorial.</li>
      </ul>

      <p>Remember that we do not care about the order at which we multiply the
      integers. This is the basic algebraic law of
      <strong>Commutativity</strong>. So, our <code>for</code> loop will
      multiply the integers incrementally, unlike the ordering which we used to
      define factorials in our math primer earlier.</p>

      <p>Good! Now, looking at the pseudocode of these algorithms, they all work
      well as expected. SCSS does not provide us with exponentiation and
      factorials, but it lets us use some basic programming language features
      like loop and flow control constructs. Thus, we do not need to "simplify"
      the coding constructs we have been using. In fact, they're literally
      almost identical as the SCSS code we'll be implementing in the next
      section. However, we may need to simplify some mathematical operations, as
      done in the paragraph below.</p>
      
      <p>Now, let's look back at our first function
      <code>sin(x)</code> and rewrite the pseudocode again, this time using the
      algorithms inside the functions we have implemented for exponentiation and
      factorials.</p>

      
      <pre><code>
        ! Preconditions:
        !       x &in; &real;
        !       serieslimit &in; N (within a reasonable, machine-sized amount)
        function sin(x, serieslimit=128)
          real :: result ! To store our intermediate calculations.

          result = x

          for (i = 1; i &lt;= serieslimit; i++)
            result = result + pow(-1, i) * pow(x, 2 &middot; i + 1) / factorial(2 * i + 1)
          end for

          return result
        end function
        ! Postconditions:
        !       &forall;x &in; &real; [-1 &le; sin(x) &le; 1]
        !       &forall;x &in; &real; [sin(x) &in; &real;]
      </code></pre>

      <p>Okay, it does look a little less Fortran and more like the Polish
      Notation. Since SCSS does not support the functions we defined earlier,
      hence we defined them ourselves, it is just what we have to do. Luckily
      for us, though, SCSS provides us with not only the basic control flow
      constructs that can be used to implement various algorithms, but also the
      notions of functions, mixins, and much more.</p>

      <p>It really may feel overwhelming. Our <code>sin(x)</code> function we
      have implemented is running <code>for</code> loops nested in
      <code>for</code> loops with more sibling <code>for</code> loops.
      <strong>HOLY SHIT FUCKING JESUS CHRIST!</strong> Well, that is the way
      things work around here, I suppose. Nevertheless, on average, the time
      complexity seems pretty constant at <span class="math">&Theta;(1)</span>.
      </p>

      <p>In this section, we have introduced some basic mathematical concepts
      and used them to implement the <span class="math">sin</span> function in
      SCSS which is crucial to rendering <em>Thicc Curve</em>. Since the content
      in this section has a potential to be an invaluable resource for those who
      are currently studying mathematics at this level, this section and the
      mathematical primers can be accessed directly by <a
      href="https://katt64.github.io/thicc/details.html#primer">this permanent
      link</a> and shared freely to whoever needs it under the <a
      href="https://creativecommons.org/licenses/by-sa/4.0/" target="_blank">CC
      BY-SA 4.0</a> license.</p>

      <p>In the next section, we will be covering how the algorithms we have
      implemented in pseudocode here in this section can be implemented in SCSS
      and implement them. Facts pertaining to the algorithm and said
      implementation in SCSS will also be discussed.</p>

      <h1>The SCSS code</h1>
      
      <!-- TODO: Add new refactored code and credit u/Thykka -->

      <p>Finally, it is about time we actually implemented the algorithm in
      SCSS. The following screengrab below should illustrate the SCSS code of
      the 3 mathematical operations we define as algorithms for the
      preprocessor to run; how the two smaller algorithms for exponentiation
      (<code>pow($base, $exponent)</code>) and factorials
      (<code>factorial($n)</code>) are used within one big algorithm to
      represent the <span class="math">sin</span> function (<code>sin($x,
        $serieslimit)</code>); and how the <code>sin</code> function is used,
      positioned, and worked on. This is the SCSS code and the main
      inner-workings of <em>Thicc Curve</em>.</p>

      <div class="figure-container">
        <img src="images/scss.png" alt="The SCSS code of Thicc Curve">
        <p>The SCSS code of Thicc Curve. (Author; Sep 7, 2017)</p>
      </div>

      <p>Lines 13-43 contain the 3 algorithms we have implemented
      earlier, re-written into SCSS. Since the logical constructs are pretty
      much the same, not a lot is changed. Lines 47-66 contain the styling rules
      responsible for coördinating how the <code>div</code>s within
      <code>div#plot-sin</code> should appear. Lines 60 - 66 is the heart of
      everything of <em>Thicc Curve</em>: it is responsible for the width of
      each div constituting a plot in the <span class="math">sin</span> function
      and the colouring it takes to highlight the changes in width.</p>

      <p>Before this revision of the doucment (Sep 7, 2017), the SCSS code had
      in it declared the <code>height: 3px;</code> property within the
      <code>for</code> loops used to assign the widths of the plotting
      <code>div</code>s. This resulted in an unsightly output CSS code that had
      314 <code>height: 3px;</code> declarations for 314 <code>div</code>s.
      Surprising is the fact that this has been overlooked for quite some time.
      <strong>I would like to thank u/Thykka over at reddit for pointing this
        out.</strong>
      Not only did he point that out, but he also mentioned that the width of
      each <code>div</code> could look better when defined as the percentage of
      the viewport's width. Again, this was something I had initially overlooked
      as I was working mostly with precise numbers, ergo values in pixels were
      the first thing to come into mind. However, after having tried some
      proportional sizing on those <code>div</code>s, it appeared &mdash; to my
      eyes &mdash; not quite as good as it was before when pixels were used.
      Thus, the values for the widths remain in pixels.</p>

      <p>For those who have worked on SCSS, the inner workings should now be
      completely obvious. We are essentially defining the width of each
      <code>div</code> as if they were plots on a graph, representing the actual
      values of the <span class="math">sin</span> function. The reason we don't
      go further and add more <code>div</code>s to our page is because CSS does
      not understand negative width values; however, even if we implemented
      another SCSS function for absolute value, the curvature of the function
      will be the same as before.</p>

      <p>As for the background coloring of each <code>div</code>, we are
      basically dividing the rainbow into 314 pieces for 314 empty
      <code>div</code>s in the webpage, and assigning each piece of color to
      each <code>div</code> of <code>div#plot-sin</code>. The background
      colouring is purely preferential. If you love grey skies and think about
      death all the time, you may define the <code>div</code>s to be grey.
      That's easy to do in CSS.</p>

      <p>Notice that the empty <code>div</code>s in <code>div#plot-sin</code>
      are not referenced with an id or class but with a number. This number acts
      like the x value of the graph of the function <span
      class="math">sin</span>. I feel it is much faster and more natural to work
      in this way.</p>

      <p>Compiling this file from SCSS into plain CSS that the browser
      understands takes on average <span class="math">9.465 seconds</span> at
      <span class="math">99%</span> CPU time with <code>SASSC</code> as the
      compiler on an Intel Core i5 dual-core processor. The computer largely
      spends a lot of time evaluating the 129-termed expansion at the function
      <code>sin</code> and writing all the values into a new CSS file on disk.
      Whilst the computer is crunching up the numbers, I usually just stare
      blankedly at the screen and contemplate deeper thoughts.</p>

      <p>At this point, the SCSS code should be obvious for you courtesy of the
      figure above. However, to make copying and pasting easier for those who
      want to try out implementing <em>Thicc Curve</em> but do not want to do
      all the typing, here is the SCSS code for the 3 functions:</p>

      <pre><code>
        /// Math toolbox

        // This definition of the 3rd hyperoperation, albeit nonvigourous, is
        // surprisingly apt for this purpose.
        //
        @function pow($base, $exponent) {
          $value: 1;

          @if $exponent &gt; 0 {
            @for $i from 1 through $exponent {
              $value: $value * $base;
            }
          }

          @return $value;
        }

        @function factorial($n) {
          $value: 1;

          @for $i from 2 through $n {
            $value: $value * $i;
          }

          @return $value;
        }

        @function sin($x, $serieslimit: 128) {
          $value: $x;

          @for $i from 1 through $serieslimit {
            $value: $value + pow(-1, $i) * pow($x, 2 * $i + 1) / factorial(2 * $i + 1);
          }

          @return $value;
        }
      </pre></code>

      <p>For being such good readers as to reading my super long article thus
      far, here is an example of how the <code>sin</code> function is used in
      the field to coördinate the styling of elements:</p>

      <pre><code>
        #plot-sin {
          position: absolute;
          top: 0;
          left: 0;

          max-width: 100%;
          overflow: hidden;

          // non-redundant `height` declaration. Thanks to u/Thykka for pointing out.
          div {
            height: 3px;
          }

          @for $i from 1 through 314 {
            div:nth-child(#{$i}) {
              width: sin($i / 100) * 1000 + 0px;
              background-color: adjust-hue(red, 360/314 * $i);
            }
          }
        }
      </code></pre>

      <p>You can copy and paste and use the code for whatever purposes you wish,
      under the terms described by the <a
        href="https://creativecommons.org/licenses/by-sa/4.0/" target="_blank">
        Creative Commons BY-SA 4.0</a> license.</p>

      <p>Apart from this implementation for the <span class="math">sin</span>
      function, I have also implemented many other functions but they did not
      look as cool or unique as the <span class="math">sin</span> function we
      have just implemented. The functions I have implemented in SCSS and their
      polynomial expansions are:</p>

      <div class="flmath">
        <ul>
          <li>3x<sup>2</sup> + 4x + 5 = 5 + 4x + 3x<sup>2</sup></li>
          <li>e<sup>x</sup> = 1 + x + x<sup>2</sup>/2 + x<sup>3</sup>/6 +
              x<sup>4</sup>/24 + &hellip; (ad infinitum)</li>
          <li>csc(x) = 1/x + x/6 + 7x<sup>3</sup>/360 + 31x<sup>5</sup>/15120 +
            127<sup>7</sup>/604800 + &hellip; (ad infinitum)</li>
          <li>ln(x) = x &minus; x<sup>2</sup>/2 + x<sup>3</sup>/3 &minus;
            x<sup>4</sup>/4 + x<sup>5</sup>/5 &minus; &hellip; (ad
            infinitum)</li>
          <li>1 / (1 &minus; x) = 1 + x + x<sup>2</sup> + x<sup>3</sup> +
            x<sup>4</sup> + &hellip; (ad infinitum)</li>
        </ul>
      </div>

      <p>Now that you see the expansions of each function, you can then quickly
      implement an algorithm for them based upon the previous algorithms we have
      defined for exponentiation and factorials and using the template from the
      <code>sin</code> function. If you want, you can try implementing them and
      <a href="https://katt64.github.io" target="_blank">reach out
        to me</a> with your <em>successful</em> attempts. Think of this as
      homework if you wish. :p</p>

      <p><strong>May you see <em>convergence</em> in all your journeys in web
        designing and mathematics! &lt;3</strong></p>

      <p>In this relatively short section, we've examined the core
      inner-workings of the <em>Thicc Curve</em> that lies within the SCSS file.
      However, it is not the SCSS itself. It is the interplay between the HTML
      file and the SCSS code, and in the grander scheme of things, it is the
      interplay between the fundamentals of mathematics and some designing sugar
      provided by SCSS. It's just really beautiful, in my opinion.</p>

      <p>One of my friends is considering a career path in web designing, but
      she has never been really keen on mathematics. The more I write this
      paper, the more I wonder how it is possible for her not to like maths!</p>

      <h1>Conclusion</h1>
      <p>This document is meant to illustrate and ultimately show-off the
      challenge I have achieved with my web development skills I have been
      learning thus far. The challenge that is implementing the <em>Thicc
        Curve</em> figure on a limited development environment. I believe that
      the document has done a good job of explaining the figure and even more so
      by providing more content to help readers gain understanding and to
      provide insight to passerbys.</p>

      <div class="figure-container">
        <img src="images/writing.png" alt="Writing this document.">
        <p>Writing this article. (Author; Sep 9, 2017)</p>
      </div>

      <p>As I kept on writing this document, however, I noticed that it was much
      more than showing off. It was a way by which I can catalogue the skills I
      have acquired and learnt, not only in web development, but in mathematics
      and computer science at school and a few other disciplines elsewhere. I
      believe that it has served more than its initial purpose as very briefly
      outlined in the Abstract of the document.</p>

      <p>By writing, I came to develop a desire. I want to prove to myself that
      I am good at whatever I am doing, feel contented with what I know and
      have, and make others feel the that they are good at whatever they are
      doing, whoever they, and feel contented with what they know and have. I
      also want them to understand that "difficult" disciplines in mathematics
      need not be difficult at all. As I have just written thus far, I have
      never expected that such a subject on continuous mathematics like calculus
      would prove useful on a finite and discrete subject like practical web
      designing and computer science. I have tried my best to write this
      document and structure it in the most beautiful way possible to showcase
      what you can possibly do with one area of math based on what I know.</p>

      <p>When I was younger, I was never really good at math. I did not
      understand trigonometry, fractions, and other relatively basic concepts
      until I turned 16. When I was even younger, math class was always a hell
      of a ride for me: my teachers hated me, and my mum would always tear up in
      dissapointment. I was so slow that my mum tried relentlessly to send
      me to after-school math courses. It was hell. As yet, however, I still
      did not do well in maths exams; I still thought &pi; was some kind
      of food and I had trouble understanding the concept of <span
      class="math">3.14</span>. My aunt was quite distressed about my exam
      results and so was my mum.</p>

      <p>By the end of high school, I will have to get really good grades for my
      exams lest I not be qualified for higher education and not get the decent
      career and life I want, and everyone has been trying to put lots of
      pressure on me to do so. Whenever I thought about exams, especially math
      exams, I would cry in dismay and regularly self-harm and contemplate
      suicide. I would feel so worthless I nearly killed myself many times with
      overdose and electricity. Then, one year ago, I decided to stop crying and
      told myself that, "I can do this, I can put the fucking knife down, I will
      live to see another day and subsequent days unscathed. I will not fucking
      kill myself." Since then, I have been trying hard to study all I can,
      especially in mathematics. Now, people seem to be liking me and I've just
      turned 17 as of this time of writing. That's good news and I'll probably
      be here on Earth for a longer while than previously expected.</p>

      <p>So, yes, you can learn anything, and mathematics is just a beautiful
      subject no matter in what field you are studying if you see the right
      picture. I disagree strongly with adults and teachers who say,
      "mathematics allows you to solve problems in real life and it gives you a
      better method by which to think, etc.," because those are not true at all.
      Mathematics is not primarily aimed to let you solve problems in real life;
      real life sucks, we all know that. Mathematics lets you fucking dream and
      forget about life and the stupidity that lies therein, and occasionally
      encourages you to come down from your dream boat and implement stuff like
      the <em>Thicc Curve</em> on a nearly-theoretical Turing Machine. Life is
      merely a subset of what is possible as defined by the Natural Philosophy.
      This is, at least, in my opinion.</p>

      <p>From this article, I hope you all take away the beauty that
      things in maths and other disciplines can be connected and most
      importantly, appreciate the beauty of <em>Thicc Curve</em>. I also hope
      you got to learn something new that may help you in web designing and
      beyond.</p>

      <p>If you would like to improve upon this article, please do so at the
      Github repository on which this document is hosted. You need some
      knowledge of HTML and SCSS and the stuff we talk about here. Also, I would
      like to invite everyone to look at the SCSS code of this page to find the
      LaTeX-like styling. If you ever find you need some LaTeX in your HTML,
      then you may as well copy the SCSS code for this page and use it as a
      guideline.</p>

      <p>All content, code, and images in this document is licensed under the <a
      href="https://creativecommons.org/licenses/by-sa/4.0/"
      target="_blank">Creative Commons BY-SA 4.0</a> license. All names of
      organizations and individuals within the main matter of this document are
      ficticious, ergo any occurrences of such names within reality is purely
      co-incidental.</p>

      <p>It's taken me days and nights to write this document and I'm glad it is
      over; I will be even more glad if it helps you in some way. It's been a
      great journey overall. Thank you for all the fish! &lt;3</p>

      <h1>Aftermath</h1>
      <p>There can never be anything <em>after math</em>. Math is the ultimate,
      purest discipline in philosophy.</p>

      <p>After having completed this challenge and writing this document, I may
      as well rewrite it but keep the same organization of content within proper
      LaTeX, not HTML, and print it as a book for myself to keep.</p>

      <p>As for the code, I may also remake the <em>Math toolbox</em> mentioned
      in &sect;The SCSS code with more functions and operations, perhaps even
      with support for complex numbers by implementing many various types of
      appropriate algorithms within it. However, if you would like to have a
      play around with the whole idea of this document, you may find yourself
      wanting to do this as well. You're welcome to do so, if you want, and I
      would love to see the results you achieve.</p>

      <p>Thus far, I think this is sufficient content for a long document. I
      might as well just stop here. This is not going to be the most appropriate
      and formal ending for such a long and carefully written article, but I'm
      very, very tired and it's 3 AM now, so &mdash;</p>

      <p><strong>Bye!</strong></p>
    </div>

    <div id="back-matter">
      <div id="copyright">Copyright &copy; 2017 <a
           href="https://katt64.github.io" target="_blank">Stephanie Björk</a>
        <br>Licensed under the <a
        href="https://creativecommons.org/licenses/by-sa/4.0/"
        target="_blank">Creative Commons BY-SA 4.0</a> license.
      </div>
    </div>

  </div>
</body>
</html>

<!--
vim: sw=2 wrap tw=80
-->
